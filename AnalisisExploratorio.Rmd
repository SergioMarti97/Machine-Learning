---
title: "Análisis Exploratorio"
author: "Sergio Martí"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Análisis Exploratorio

Se parten de cuatro archivos distintos que analizar: datos clínicos, datos del sistema inmunológico, datos del análisis digital del tumor y datos procedentes de cuantificación de RNA-seq. Para cada achivo se debe de responder a las siguientes preguntas:

-   Número de predictores.
-   Número de muestras.
-   Tipo de identificador correspondiente al paciente.
-   Cantidad de pacientes con datos disponibles en las cuatro fuentes de datos.

## Datos clínicos.

Los datos clínicos se encuentra en formato "csv" (coma separeted values) dentro del archivo llamado "Main.csv".

```{r}
# Lemos los datos clínicos
dfClinical <- read.csv("./datos/Main.csv")

# Visualizar el dataframe
View(dfClinical)
```

El número de muestras se puede obtener contando el número de registros:

```{r}
# Número de registros
nrow(dfClinical)
```

El número de predictores se pude calcular a partir del número de variables del dataframe:

```{r}
# Número de columnas
ncol(dfClinical)
```

A partir de aquí hay que descontar las variables que no son predictores. Las variables "X" y "Trial.ID" son los identificadores de los pacientes. La variable "resp.pCR" determina si la paciente ha respondido de forma satisfactoria al nuevo tratamiento. Las variables: "resp.Chemosensitive", "resp.Chemoresistant", "RCB.score" y "RCB.category" son redundantes con la primera.

```{r}
summary(dfClinical)

ncol(dfClinical[,7:ncol(dfClinical)])
```

Hay 68 variables clínicas que se pueden utilizar como predictores.

```{r}
# Encontrar si hay algún dato "Not Available"
sum(is.na(dfClinical[,3:ncol(dfClinical)])) > 1

# Encontrar si hay algún dato nulo
sum(is.null(dfClinical[,3:ncol(dfClinical)])) > 1
```

No hay ningún registro que sea "Not Available" (NA) o nulo (NULL) en las variables clínicas.

Si hubiera algún dato nulo o not available, dependiendo de la naturaleza de los datos se podrían tomar diferentes estratégias para resolver el problema: una opción es decidir que no trabajar con los registros que contienen nulos. Es una buena opción si se tiene una muestra muy grande, pero se tiene que tener en cuenta que se pierde información al realiar esta selección. Otra opción es asignar el valor promedio de la variable a los registros con datos nulos o not available. Si la variable es de tipo categórica/cualitativa, se puede asignar el valor que más se repite. Si la variable es cuantitativa, se puede asignar el valor estadístico de la media o la moda.

```{r}
# Naturaleza de las variables

# Seleccionamos solamente las variables que no son predictoras
dfClinicalVars <- dfClinical[,8:ncol(dfClinical)]

# Comprobamos la naturaleza de las variables
str(dfClinicalVars)

# Guardamos en un vector boleano si la variable es entera o numerica
colsInt <- sapply(dfClinicalVars, is.integer)

# Seleccionamos en base al vector las columnas de datos enteros y datos continuos
intVars <- dfClinicalVars[colsInt]
numVars <- dfClinicalVars[!colsInt]

# Eliminamos el vector de columnas enteras, ya no es necesario
rm(colsInt)

# Para cada variable entera, comprobamos si es un factor
lIsFactor <- lapply(intVars, function(v) {
  return(levels(as.factor(v)))
})

# Comprobamos con la variable lIsFactor que hay variables enteras con 2 niveles (factores) y variables con más de 2 niveles. Las variables con 2 niveles son cualitativas y las demás son cuantitativas de números enteros.
lIsFactor <- sapply(intVars, function(v) {
  return(!(length(levels(as.factor(v))) > 2)) 
})

# Seleccionamos las variables que son factores
facVars <- intVars[lIsFactor] 

numVars <- cbind(numVars, intVars[!lIsFactor])

# Eliminamos las variables enteras, ya no son necesarias
# rm(intVars)

facVars[,1:ncol(facVars)] <- lapply(facVars[,1:ncol(facVars)], factor)
summary(facVars)
```

Obtenemos que hay 54 variables númericas (43 reales y 11 enteras) y 13 variables de tipo factor.

```{r}
library(corrplot)

mCor <- cor(normalize(numVars))

corrplot(mCor, method = "color", # Correlation plot method
         order = "hclust",
         addrect = 5,
         type = "full",    # Correlation plot style (also "upper" and "lower")
         diag = TRUE,      # If TRUE (default), adds the diagonal
         tl.col = "black",
         tl.cex = 0.4)
```

